---
title: "Simulation Study"
output: pdf_document
---

<!-- source load_dependencies later -->
<!-- Automatically detect and download libraries -->
<!-- download conflicted package -->
```{r}
library(survival)
library(glmnet)
library(polspline)
library(knitr)
library(EnvStats)
library(bda)
library(tictoc)
library(abind)
library(fitdistrplus)
```

# Function for Simulating Survival Time from a Weibull Distribution

This function is based on simulate_data in https://cran.r-project.org/web/packages/rsimsum/vignettes/relhaz.html

```{r}
#' Simulate survival times with censoring, based on a weibull baseline hazard
#'
#' This function simulates survival times with censoring, according to a weibull
#' baseline hazard that the user parameterizes. The survival times are 
#' simulated for user-given covariates and coefficients, and the censoring times
#' are simulated for a user-given distribution.
#' @param x model matrix of covariate values
#' @param fcts_select subset of fcts from a hare object containing the coefficients of interest. 
#' @param params parameters shape and scale for the baseline Weibull distribution, 
#' by default the exponential distribution with scale = 1
#' @param FUN random generation function for the distribution of censoring times, 
#' expected to be uniform, exponential, or weibull. 
#' @param ... arguments for FUN, the random generation function
#' @return dataframe appending survival time and censoring indicator to the model matrix x
#' @export
simulate_weibull <- function(x, fcts_select, params = list(shape = 1, scale = 1), FUN, ...) {
  
  n <- nrow(x)
  
  # extract unique list of covariates selected 
  cov_nums <- sort(fcts_select[,1][fcts_select[,1] != 0])
  cov_names <- colnames(x)[cov_nums]
  x_select <- x[,cov_names]
  
  # extract the coefficient values from fcts_select
  betas <- fcts_select[,5][fcts_select[,1] != 0]
  betas <- betas[order(fcts_select[,1][fcts_select[,1] != 0])]
  
  # simulate survival times according to Bender et al. (2005)
  u <- runif(n)
  time <- (-log(u) / (params$scale * exp(x_select %*% betas)))^(1 / params$shape)
  
  # Winsorising tiny values for time (smaller than one day on a yearly-scale, e.g. 1 / 365.242),
  # and adding a tiny amount of white noise not to have too many concurrent values
  time <- ifelse(time < 1 / 365.242, 1 / 365.242, time)
  time[time == 1 / 365.242] <- time[time == 1 / 365.242] + 
    rnorm(length(time[time == 1 / 365.242]), mean = 0, sd = 1e-4)
  # ...and make sure that the resulting value is positive
  time <- abs(time)
  
  # Censoring
  cid_time <- FUN(n, ...)
  
  cid <- ifelse(time < cid_time, 1, 0)
  
  time <- pmin(time, cid_time)
  
  # return a dataframe
  data.frame(time, cid, x)
}
```

# Function for Simulating Survival Time from a Log-normal Distribution

```{r}
#' Simulate survival times with censoring, based on a log-normal distribution
#'
#' This function simulates survival times with censoring, according to a log-normal distribution
#' that the user parameterizes. The survival times are 
#' simulated for user-given covariates and coefficients, and the censoring times
#' are simulated for a user-given distribution.
#' @param x model matrix of covariate values 
#' @param fcts_select subset of fcts from a hare object containing the coefficients of interest. 
#' @param params parameters shape and scale for the baseline log-normal distribution
#' @param FUN random generation function for the distribution of censoring times, 
#' expected to be uniform, exponential, or weibull. 
#' @param ... arguments for FUN, the random generation function
#' @return dataframe appending survival time and censoring indicator to the model matrix x
#' @export
simulate_lnorm <- function(x, fcts_select, params, FUN, ...) {
  
  n <- nrow(x)
  
  # extract unique list of covariates selected 
  cov_nums <- sort(fcts_select[,1][fcts_select[,1] != 0])
  cov_names <- colnames(x)[cov_nums]
  x_select <- x[,cov_names]
  
  # extract the coefficient values from fcts_select
  betas <- fcts_select[,5][fcts_select[,1] != 0]
  betas <- betas[order(fcts_select[,1][fcts_select[,1] != 0])]
  
  # simulate survival times based on the survsim package
  time <- c()
  # going row by row in the original ACTG-175 data set, simulating the survival time depending on
  # whether Offtrt = 0 or 1.
  for (i in 1:n) {
    
    time[i] <- rlnorm(1, params$meanlog + x_select[i,] %*% betas, params$sdlog)
    
  }
  
  # Winsorising tiny values for time (smaller than one day on a yearly-scale, e.g. 1 / 365.242),
  # and adding a tiny amount of white noise not to have too many concurrent values
  time <- ifelse(time < 1 / 365.242, 1 / 365.242, time)
  time[time == 1 / 365.242] <- time[time == 1 / 365.242] + 
    rnorm(length(time[time == 1 / 365.242]), mean = 0, sd = 1e-4)
  # ...and make sure that the resulting value is positive
  time <- abs(time)
  
  # Censoring
  cid_time <- FUN(n, ...)
  
  cid <- ifelse(time < cid_time, 1, 0)
  
  time <- pmin(time, cid_time)
  
  # return a dataframe
  data.frame(time, cid, x)
}
```

# Setting up the requisite parameters for simulation

```{r}
load("actg175.RData")

x <- model.matrix( ~ trt + age + wtkg + hemo + drugs +
                     karnof + oprior + preanti + race +
                     gender + symptom + offtrt + cd40 +
                     cd80, actg175)[,-1]

nphm_hare <- readRDS("nphm_hare.rds")

# extracting the coefficients for basis functions 
# that do not correspond to knots and/or tensor products
fcts <- nphm_hare$fcts
fcts_select <- fcts[fcts[,2] == 0 & is.na(fcts[,3]),]
```

# Generating example data set from the Weibull distribution 

## Using arbitrary Weibull parameter values to get similar survival times as original study

```{r}
set.seed(2)

test_sim_mat <- simulate_weibull(x, fcts_select, 
                                 params = list(shape = 500,
                                               scale = 1),
                                 FUN = rexp, 1.3)

summary(test_sim_mat$time)

mean(test_sim_mat$cid)
```

## Using Weibull parameter estimates from fit.Weibull

```{r}
set.seed(1)

parm_res <- fit.Weibull(rhare(100000, cov = rep(0, nphm_hare$ncov), nphm_hare), dist="Weibull")
```

```{r}
set.seed(2)

sim_mat <- simulate_weibull(x, fcts_select, 
                            params = list(shape = parm_res$pars[2],
                                          scale = parm_res$pars[1]), 
                            FUN = rexp, 1.3)

summary(sim_mat$time)

# censoring rate for the simulated data set
1 - mean(sim_mat$cid)

# censoring rate for the original study
1 - mean(actg175$cid)

1 - mean(sim_mat$cid) == 1 - mean(actg175$cid)
```

If I use a random seed of 1 in line 111, a random seed of 2 in line 117, and use the rate parameter of 1.3 in line 122, I get the exact same censoring rate as in the original study, which is very strange. 



# Generating example data set from the Log-normal distribution 

```{r}
set.seed(2)

sim_mat_lnorm <- simulate_lnorm(x, fcts_select, 
                                params = list(meanlog = -10,
                                              sdlog = 1), 
                                FUN = rexp, 1.3)

summary(sim_mat_lnorm$time)

# censoring rate for the simulated data set
1 - mean(sim_mat_lnorm$cid)
```




# Coxph Simulation

## Using arbitrary Weibull parameter values

```{r, warning = FALSE}
phm_test_sim_mat <- coxph(Surv(time, cid) ~ ., data = test_sim_mat)

phm_test_sim_mat
```

## Using Weibull parameter estimates from fit.Weibull

```{r, warning = FALSE}
phm_sim_mat <- coxph(Surv(time, cid) ~ ., data = sim_mat)

summary(phm_sim_mat)

cox.zph(phm_sim_mat)
```

## Log-normal distributed survival times

```{r}
phm_sim_mat_lnorm <- coxph(Surv(time, cid) ~ ., data = sim_mat_lnorm)

summary(phm_sim_mat_lnorm)

cox.zph(phm_sim_mat_lnorm)
```

Preanti instead of offtrt was determined to be the covariate violating the proportional hazards assumption.

# Weibull model (to compare with Coxph), (Weibull distributed survival times)

The Weibull model should be more powerful (with less variance in the coefficient estimates) than the Cox Proportional Hazards model, as the data is from a Weibull distribution. The coefficient estimates themselves should be similar.

```{r}
summary(survreg(Surv(time, cid) ~ ., data = sim_mat))
```

For coefficients with very low p-values (p < 2e-16) according to the coxph model, the values from the Weibull model are approximately equal to those from the coxph model divided by -100. 



# Glmnet Simulation

## Weibull distributed survival times

```{r}
cv_phmnet <- cv.glmnet(as.matrix(sim_mat[-c(1,2)]), 
                       Surv(sim_mat$time, sim_mat$cid),
                       family = "cox", alpha = .95)
```

```{r}
coef(cv_phmnet, s = cv_phmnet$lambda.1se)
```

## Log-normal distributed survival times

```{r}
cv_phmnet_lnorm <- cv.glmnet(as.matrix(sim_mat_lnorm[-c(1,2)]), 
                             Surv(sim_mat_lnorm$time, sim_mat_lnorm$cid),
                             family = "cox", alpha = .95)
```

```{r}
coef(cv_phmnet_lnorm, s = cv_phmnet_lnorm$lambda.1se)
```



# PH HARE Simulation

## Weibull distributed survival times

```{r}
phm_hare <- hare(sim_mat$time, sim_mat$cid, as.matrix(sim_mat[-c(1,2)]), prophaz = TRUE)

# extracting the coefficients for basis functions 
# that do not correspond to time, knots, and/or tensor products
(fcts <- phm_hare$fcts)

# cat("\n")
# 
# fcts[fcts[,1] != 0 & fcts[,2] == 0 & is.na(fcts[,3]),]
```

## Log-normal distributed survival times

```{r}
phm_hare_lnorm <- hare(sim_mat_lnorm$time, sim_mat_lnorm$cid, 
                       as.matrix(sim_mat_lnorm[-c(1,2)]), prophaz = TRUE)

# extracting the coefficients for basis functions 
# that do not correspond to time, knots, and/or tensor products
(fcts <- phm_hare_lnorm$fcts)

# cat("\n")
# 
# fcts[fcts[,1] != 0 & fcts[,2] == 0 & is.na(fcts[,3]),]
```



# non-PH HARE Simulation

## Weibull distributed survival times

```{r}
nphm_hare_sim <- hare(sim_mat$time, sim_mat$cid, as.matrix(sim_mat[-c(1,2)]))

# extracting the coefficients for basis functions 
# that do not correspond to time, knots, and/or tensor products
(fcts <- nphm_hare_sim$fcts)

# cat("\n")
# 
# fcts[fcts[,1] != 0 & fcts[,2] == 0 & is.na(fcts[,3]),]

# Which covariates have an interaction with time (or a knot of it)?
unique(fcts[fcts[,1] == 0 & !is.na(fcts[,3]), 3])

```


## Log-normal distributed survival times

```{r}
nphm_hare_sim_lnorm <- hare(sim_mat_lnorm$time, sim_mat_lnorm$cid, as.matrix(sim_mat_lnorm[-c(1,2)]))

(fcts <- nphm_hare_sim_lnorm$fcts)

# Which covariates have an interaction with time (or a knot of it)?
unique(fcts[fcts[,1] == 0 & !is.na(fcts[,3]), 3])
```

# Simulating N = 100 Times

```{r}
#' Select and calculate coefficient estimates for Cox PH, penalized PH, HARE PH, 
#' and HARE non-PH models based on N simulated data sets.
#'
#' This function calls the simulation function for the distribution of interest N
#' times and calculates the corresponding regression coefficient estimates for 
#' each simulated data set.
#' @param N number of simulated data sets to fit the models to. 
#' @param p number of covariates in original dataset
#' @param simulate_fun simulation function for the distribution of interest.
#' @param ... arguments for simulate_fun
#' @return p x 4 x N array containing the coefficient estimates for variables 
#' selected among p initial variables by 4 models fitted on N data sets
#' @export
simulate_regression <- function(N, p, simulate_fun = simulate_weibull, ...) {
  
  res <- array(NA, dim = c(p, 4, N))
  
  for (i in 1:N) {
    
    sim_mat <- simulate_fun(...)
    
    
    # Cox Proportional Hazards model
    phm_sim_mat <- coxph(Surv(time, cid) ~ ., data = sim_mat)
    
    s_phm_sim_mat <- summary(phm_sim_mat)
    
    # only storing the coefficient values for which the p-value is <= .05
    res[s_phm_sim_mat$coefficients[,5] <= .05, 1, i] <-
      phm_sim_mat$coefficients[s_phm_sim_mat$coefficients[,5] <= .05]
    
    
    # Penalized Proportional Hazards model
    cv_phmnet <- cv.glmnet(as.matrix(sim_mat[-c(1,2)]),
                           Surv(sim_mat$time, sim_mat$cid),
                           family = "cox", alpha = .95)
    
    selected_coef <- as.numeric(coef(cv_phmnet, s = cv_phmnet$lambda.1se))
    
    res[selected_coef != 0, 2, i] <- selected_coef[selected_coef != 0]
    
    
    
    # PH HARE model
    phm_hare <- hare(sim_mat$time, sim_mat$cid, 
                     as.matrix(sim_mat[-c(1,2)]), prophaz = TRUE)
    
    # extracting the coefficients for basis functions 
    # that do not correspond to time, knots, and/or tensor products
    fcts <- phm_hare$fcts
    fcts_select <- fcts[fcts[,1] != 0 & fcts[,2] == 0 & is.na(fcts[,3]),]
    
    res[fcts_select[,1], 3, i] <- fcts_select[,5]
    
    
    
    # non-PH HARE model 
    nphm_hare <- hare(sim_mat$time, sim_mat$cid, as.matrix(sim_mat[-c(1,2)]))
    
    # extracting the coefficients for basis functions 
    # that do not correspond to time, knots, and/or tensor products
    nphm_fcts <- nphm_hare$fcts
    nphm_fcts_select <- nphm_fcts[nphm_fcts[,1] != 0 &
                                    nphm_fcts[,2] == 0 & is.na(nphm_fcts[,3]),]
    
    res[nphm_fcts_select[,1], 4, i] <- nphm_fcts_select[,5]
    
  }
  
  return(res)
  
}
```

## Weibull distributed survival times

I tried to do 500 simulate_regression iterations, but it was too much for R to handle. I do 100 simulations instead.

```{r}
set.seed(636)

tic()
sims <- simulate_regression(N = 100, p = 16, simulate_fun = simulate_weibull, x, fcts_select,
                            params = list(shape = parm_res$pars[2],
                                          scale = parm_res$pars[1]),
                            FUN = rexp, rate = 1.3)

save(sims, file = "sims2.RData")
toc()
```

If I use set.seed(3), then there would be an error regarding the fitter() function (something about NA/NaN/Inf""). But with this set.seed, the coxph model still works. 

Regarding "Loglik converged before variable..." see https://stat.ethz.ch/pipermail/r-help/2008-September/174201.html. 

Proportion of times each covariate is selected across the four models fitted on simulated
survival times from the Weibull distribution (this will be Table 5a in the manuscript)
```{r}
load("sims2.RData")

prop_weibull <- matrix(0, nrow = 16, ncol = 4)

for (i in 1:16) {
  
  for (j in 1:4) {
    
    prop_weibull[i,j] <- sum(!is.na(sims[i, j,])) / dim(sims)[3]
    
  }
  
}

prop_weibull
```



## Log-normal distributed survival times

```{r}
set.seed(636)

tic()
sims <- simulate_regression(N = 100, p = 16, simulate_fun = simulate_lnorm, x, 
                            fcts_select, params = list(meanlog = -10, sdlog = 1),
                            FUN = rexp, rate = 1.3)

save(sims, file = "sims_lnorm2.RData")
toc()
```

This simulation process took 586.108 seconds (~ 10 minutes).

 

    Proportion of times each covariate is selected across the four models fitted on simulated 
    survival times from the Log-normal distribution (this will be Table 5c in the manuscript)
```{r}
load("sims_lnorm2.RData")

prop_lnorm <- matrix(0, nrow = 16, ncol = 4)

for (i in 1:16) {
  
  for (j in 1:4) {
    
    prop_lnorm[i,j] <- sum(!is.na(sims[i, j,])) / dim(sims)[3]
    
  }
  
}

prop_lnorm
```

Update to do later: track how many times the tensor product with time (indicating violation of proportional hazards) was selected for a specific covariate (ideally Offtrt)
